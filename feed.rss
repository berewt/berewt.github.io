<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Codice and Circenses</title>
        <link>http://nicolas.biri.name/</link>
        <description><![CDATA[IT, Programming, boardgames and random thoughts]]></description>
        <atom:link href="http://nicolas.biri.name//feed.rss" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sat, 19 May 2018 00:00:00 UT</lastBuildDate>
        <item>
    <title>Dependent types as tests</title>
    <link>http://nicolas.biri.name//posts/2018-05-19-Dependent-types-as-tests.html</link>
    <description><![CDATA[<div class="info">
    Posted on May 19, 2018
    
        by Nicolas Biri
    
</div>

<p>Types are not supposed to replace tests… in general. However, dependent types allow you to express tests as types, allowing you to run your tests automatically at compile times. Even better, you can express property tests and prove them rather than test them on a large subset of values.</p>
<p>To be accurate, we’re not talking about tests here, rather of proofs. I’m using <em>tests</em> just because what we’re checking can be compared to what we usually check with usual tests. Please don’t mind if I don’t use the appropriate term in favor of a more informal terms, I just want to prove to people that we can replace tests with a better alternative, with the appropriate language.</p>
<p>This article illustrates this possibility through the <a href="http://codingdojo.org/kata/Tennis/">tennis kata</a>. Our objective, provide a way to compute and display a tennis score (of only one game) correctly, and prove that our code is right. Let’s see how “if it compiles, you can ship it” can be real.</p>
<p>The code used in this article is available as <a href="https://gist.github.com/berewt/c131ad538c0bc0989835f7d7cd3e48f8">a gist</a>.</p>
<h1 id="the-tennis-kata-with-dependent-types">The tennis kata with dependent types</h1>
<h1 id="types-types-types">Types, types, types</h1>
<p>First, let’s write some idris to encode the score progression and scores display.</p>
<p>To encode the score, we use the following rules. To win a game, a player must:</p>
<ul>
<li>have scored at least four points;</li>
<li><strong>and</strong> must be ahead by at least two points.</li>
</ul>
<p>We start by the obvious, we need two players:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Player</span> <span class="fu">=</span> <span class="dt">Player1</span> <span class="fu">|</span> <span class="dt">Player2</span></code></pre></div>
<p>A classical way to represent score is to use two naturals. This encoding however, allows a lot of invalid combination. For example, 5-0 is not a valid score, as the previous score, 4-0, should already have led to the end of the game.</p>
<p>A way to tackle this with dependent type is to embed in a score a proof that the game is not over. Let’s build a type that can prove that nobody has won yet:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="co">||| Prove that the game is not over after a point</span>
<span class="kw">data</span> <span class="dt">NotWinning</span> <span class="ot">:</span> (winnerScore<span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> (loserScore<span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="co">||| Game is not over because the winning player is below 40</span>
  <span class="dt">ThresholdNotMet</span> <span class="ot">:</span> <span class="dt">LTE</span> x <span class="dv">3</span> <span class="ot">-&gt;</span> <span class="dt">NotWinning</span> x y
  <span class="co">||| Game is not over because we only reach deuce or advantage</span>
  <span class="dt">OpponentTooClose</span> <span class="ot">:</span> <span class="dt">LTE</span> x (<span class="dt">S</span> y) <span class="ot">-&gt;</span> <span class="dt">NotWinning</span> x y</code></pre></div>
<p>The first constructor is a proof that nobody has won because the winner of a point has not reached 4 points yet (they have less or equal to 3 points). The second constructor is a proof that the winner of a point is not 2 points ahead yet.</p>
<p>Now that we have a type for our proofs, let’s write a decision procedure to build a proof or to prove the lack of proof that a game is over depending on a score:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="co">||| Decision procedure to obtain a NotWinningProof</span>
<span class="fu">notWinning</span> <span class="ot">:</span> (winnerScore <span class="ot">:</span> <span class="dt">Nat</span>)
              <span class="ot">-&gt;</span> (loserScore <span class="ot">:</span> <span class="dt">Nat</span>)
              <span class="ot">-&gt;</span> <span class="dt">Dec</span> (<span class="dt">NotWinning</span> winnerScore loserScore)
notWinning winnerScore loserScore <span class="fu">=</span>
  <span class="kw">case</span> isLTE winnerScore <span class="dv">3</span> <span class="kw">of</span>
       (<span class="dt">Yes</span> prfT)    <span class="ot">=&gt;</span> <span class="dt">Yes</span> (<span class="dt">ThresholdNotMet</span> prfT)
       (<span class="dt">No</span> contraT) <span class="ot">=&gt;</span> <span class="kw">case</span> isLTE winnerScore (<span class="dt">S</span> loserScore) <span class="kw">of</span>
                            <span class="dt">Yes</span> prfO <span class="ot">=&gt;</span> <span class="dt">Yes</span> (<span class="dt">OpponentTooClose</span> prfO)
                            <span class="dt">No</span> contraO <span class="ot">=&gt;</span> <span class="dt">No</span> (winningProof contraT contraO)
  <span class="kw">where</span>
    <span class="fu">winningProof</span> <span class="ot">:</span> (contraT <span class="ot">:</span> <span class="dt">Not</span> (<span class="dt">LTE</span> winnerScore <span class="dv">3</span>))
                <span class="ot">-&gt;</span> (contraO <span class="ot">:</span> <span class="dt">Not</span> (<span class="dt">LTE</span> winnerScore (<span class="dt">S</span> loserScore)))
                <span class="ot">-&gt;</span> <span class="dt">Not</span> (<span class="dt">NotWinning</span> winnerScore loserScore)
    winningProof contraT contraO (<span class="dt">ThresholdNotMet</span> x) <span class="fu">=</span> contraT x
    winningProof contraT contraO (<span class="dt">OpponentTooClose</span> x) <span class="fu">=</span> contraO x</code></pre></div>
<p>We check each condition that are necessary to build one of our constructors. If one of the two condition is met, we are able to provide our proof, otherwise we use the two witnesses that our conditions aren’t met to prove that we cannot build a witness that the game is not over (i.e., we have a winner).</p>
<h2 id="score">Score</h2>
<p>From there, we are able to define a type for the score of an ongoing game:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="co">||| Score is built by stacking ball winners, along with the proof that the game is not over</span>
<span class="kw">data</span> <span class="dt">Score</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">Start</span> <span class="ot">:</span> <span class="dt">Score</span> <span class="dv">0</span> <span class="dv">0</span>
  <span class="dt">Player1Scores</span> <span class="ot">:</span> <span class="dt">Score</span> x y <span class="ot">-&gt;</span> {<span class="kw">auto</span> prf<span class="ot">:</span> <span class="dt">NotWinning</span> (<span class="dt">S</span> x) y} <span class="ot">-&gt;</span> <span class="dt">Score</span> (<span class="dt">S</span> x) y
  <span class="dt">Player2Scores</span> <span class="ot">:</span> <span class="dt">Score</span> x y <span class="ot">-&gt;</span> {<span class="kw">auto</span> prf<span class="ot">:</span> <span class="dt">NotWinning</span> (<span class="dt">S</span> y) x} <span class="ot">-&gt;</span> <span class="dt">Score</span> x (<span class="dt">S</span> y)</code></pre></div>
<p>Our score type does not exactly handle the score. It’s rather a list of points winners, tied with the proof that the game is not over.</p>
<p>We’re almost ready to implement the function that allows a player to score a point. Before, we need a helper to compute the next score, given a point winner and a player, we compute the hypothetical next score of this player (if the game is not over):</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">nextScore</span> <span class="ot">:</span> (winner <span class="ot">:</span> <span class="dt">Player</span>) <span class="ot">-&gt;</span> (pointsOwner <span class="ot">:</span> <span class="dt">Player</span>) <span class="ot">-&gt;</span> (points <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> <span class="dt">Nat</span>
nextScore <span class="dt">Player1</span> <span class="dt">Player1</span> points <span class="fu">=</span> <span class="dt">S</span> points
nextScore <span class="dt">Player1</span> <span class="dt">Player2</span> points <span class="fu">=</span> points
nextScore <span class="dt">Player2</span> <span class="dt">Player1</span> points <span class="fu">=</span> points
nextScore <span class="dt">Player2</span> <span class="dt">Player2</span> points <span class="fu">=</span> <span class="dt">S</span> points</code></pre></div>
<p>And here we go with the scoring:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="co">||| Add the result of a point to a score</span>
<span class="fu">score</span> <span class="ot">:</span> (previousScore <span class="ot">:</span> <span class="dt">Score</span> p1Points p2Points)
      <span class="ot">-&gt;</span> (p <span class="ot">:</span> <span class="dt">Player</span>)
      <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Score</span> (nextScore p <span class="dt">Player1</span> p1Points)
                      (nextScore p <span class="dt">Player2</span> p2Points))
score previousScore p {p1Points} {p2Points} <span class="fu">=</span>
  <span class="kw">case</span> notWinning (winnerPoints p) (loserPoints p) <span class="kw">of</span>
       <span class="dt">Yes</span> <span class="fu">_</span>      <span class="ot">=&gt;</span> pure (builder p)
       <span class="dt">No</span>  contra <span class="ot">=&gt;</span> 
  <span class="kw">where</span>
    <span class="fu">winnerPoints</span> <span class="ot">:</span> <span class="dt">Player</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>
    winnerPoints <span class="dt">Player1</span> <span class="fu">=</span> <span class="dt">S</span> p1Points
    winnerPoints <span class="dt">Player2</span> <span class="fu">=</span> <span class="dt">S</span> p2Points
    <span class="fu">loserPoints</span> <span class="ot">:</span> <span class="dt">Player</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>
    loserPoints  <span class="dt">Player1</span> <span class="fu">=</span> p2Points
    loserPoints  <span class="dt">Player2</span> <span class="fu">=</span> p1Points
    <span class="fu">builder</span> <span class="ot">:</span> (p <span class="ot">:</span> <span class="dt">Player</span>)
    <span class="ot">-&gt;</span> {<span class="kw">auto</span> prf <span class="ot">:</span> <span class="dt">NotWinning</span> (winnerPoints p) (loserPoints p)}
           <span class="ot">-&gt;</span> <span class="dt">Score</span> (nextScore p <span class="dt">Player1</span> p1Points) (nextScore p <span class="dt">Player2</span> p2Points)
    builder <span class="dt">Player1</span> <span class="fu">=</span> <span class="dt">Player1Scores</span> previousScore
    builder <span class="dt">Player2</span> <span class="fu">=</span> <span class="dt">Player2Scores</span> previousScore</code></pre></div>
<p>The <code>score</code> function, given the winner of a point, will either returns the next score or nothing, if the winner of the point won the game. The code almost entirely relies on the <code>notWinning</code> function, which provides either the proof needed to build the next score, or the proof that we have a winner.</p>
<p>Then, we can replay a whole game quite easily with <code>foldlM</code>:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="co">||| Replay a full list of points, if the game ends, the remaining points are discarded</span>
<span class="fu">replay</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Player</span> <span class="ot">-&gt;</span>  <span class="dt">Either</span> <span class="dt">Player</span> (x&#39; <span class="fu">**</span> y&#39; <span class="fu">**</span> <span class="dt">Score</span> x&#39; y&#39;)
replay <span class="fu">=</span> foldlM f (<span class="fu">_</span> <span class="fu">**</span> (<span class="fu">_</span> <span class="fu">**</span> <span class="dt">Start</span>))
  <span class="kw">where</span>
    <span class="fu">f</span> <span class="ot">:</span> (a <span class="fu">**</span> b <span class="fu">**</span> <span class="dt">Score</span> a b) <span class="ot">-&gt;</span> <span class="dt">Player</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Player</span> (x&#39; <span class="fu">**</span> y&#39; <span class="fu">**</span> <span class="dt">Score</span> x&#39; y&#39;)
    f (<span class="fu">_</span> <span class="fu">**</span> <span class="fu">_</span> <span class="fu">**</span> s) p <span class="fu">=</span> maybe (<span class="dt">Left</span> p)
                              (pure <span class="fu">.</span> (<span class="fu">\</span>s&#39; <span class="ot">=&gt;</span> (<span class="fu">_</span> <span class="fu">**</span> <span class="fu">_</span> <span class="fu">**</span> s&#39;)))
                              <span class="fu">$</span> score s p</code></pre></div>
<p>The result of a replay is either a winner, or an existential type (or Σ-type) with the current score. The existential type is required since we do not know in advance what the score will be.</p>
<h2 id="display">Display</h2>
<p>We’re almost there, we just need a few facilities to display the score: We start with a helper that displays points in the usual and weird tennis style. The points are announced only for the 3 first points of a player (before, the <em>deuce</em> and <em>advantage</em> part), thus we need a proof that we are less or equal to 3 to display the points:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">displayPoints</span> <span class="ot">:</span> <span class="dt">LTE</span> x <span class="dv">3</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
displayPoints <span class="dt">LTEZero</span> <span class="fu">=</span> <span class="st">&quot;0&quot;</span>
displayPoints (<span class="dt">LTESucc</span> <span class="dt">LTEZero</span>) <span class="fu">=</span> <span class="st">&quot;15&quot;</span>
displayPoints (<span class="dt">LTESucc</span> (<span class="dt">LTESucc</span> <span class="dt">LTEZero</span>)) <span class="fu">=</span> <span class="st">&quot;30&quot;</span>
displayPoints (<span class="dt">LTESucc</span> (<span class="dt">LTESucc</span> (<span class="dt">LTESucc</span> <span class="dt">LTEZero</span>))) <span class="fu">=</span> <span class="st">&quot;40&quot;</span></code></pre></div>
<p>And we can now display the whole score, starting with the special cases and then the general one:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">displayScore</span> <span class="ot">:</span> <span class="dt">Score</span> x y <span class="ot">-&gt;</span> <span class="dt">String</span>
displayScore {x <span class="fu">=</span> <span class="dt">Z</span>} {y <span class="fu">=</span> <span class="dt">Z</span>} <span class="fu">_</span> <span class="fu">=</span> <span class="st">&quot;love&quot;</span>
displayScore {x <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))} {y <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))} <span class="fu">_</span> <span class="fu">=</span> <span class="st">&quot;deuce&quot;</span>
displayScore {x} {y} <span class="fu">_</span> <span class="fu">=</span> <span class="kw">case</span> (isLTE x <span class="dv">3</span>, isLTE y <span class="dv">3</span>) <span class="kw">of</span>
  (<span class="dt">Yes</span> prfX,   <span class="dt">Yes</span> prfY)   <span class="ot">=&gt;</span> concat [displayPoints prfX
                                     , <span class="st">&quot; - &quot;</span>
                                     , displayPoints prfY
                                     ]
  <span class="fu">_</span>                        <span class="ot">=&gt;</span> <span class="kw">case</span> compare x y <span class="kw">of</span>
                                   <span class="dt">LT</span> <span class="ot">=&gt;</span> <span class="st">&quot;advantage Player2&quot;</span>
                                   <span class="dt">EQ</span> <span class="ot">=&gt;</span> <span class="st">&quot;deuce&quot;</span>
                                   <span class="dt">GT</span> <span class="ot">=&gt;</span> <span class="st">&quot;advantage Player1&quot;</span></code></pre></div>
<h1 id="tests">Tests</h1>
<p>Isn’t this article supposed to be about testing? Well… here we are.</p>
<h2 id="unit-testing">Unit testing</h2>
<p>Let start with something simple. If we provide a way to <code>replay</code> an empty list of points, the score must be unchanged. A usual way to test it in a language without dependent type would be something like:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="co">||| pseudocode, does not compile</span>
<span class="fu">replayEmptyListGivesStart</span> <span class="ot">:</span> <span class="dt">IO</span> <span class="dt">Bool</span>
replayEmptyListGivesStart <span class="fu">=</span> assertEqual (<span class="dt">Right</span> (<span class="dv">0</span> <span class="fu">**</span> <span class="dv">0</span> <span class="fu">**</span> <span class="dt">Start</span>)) (replay [])</code></pre></div>
<p>Well, we can actually do better:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">replayEmptyListGivesStart</span> <span class="ot">:</span> <span class="dt">Right</span> (<span class="dv">0</span> <span class="fu">**</span> <span class="dv">0</span> <span class="fu">**</span> <span class="dt">Start</span>) <span class="fu">=</span> replay []
replayEmptyListGivesStart <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>This is a compile time test. We have expressed here that <code>replayEmptyListGivesStart</code> is an element of the structural equality between <code>Right (0 ** 0 ** Start)</code> and <code>replay []</code>. We are even able to provide this element which is <code>Refl</code>. Behind the hood, the compiler will rewrite <code>replay []</code>, be able to reduce it <code>Right (0 ** 0 * Start)</code>. And as <code>Refl</code> is of type <code>a = a</code>, it’s a correct value for this type and our program compiles!</p>
<p>We’ve just embedded in our program a <em>proof</em> that <code>Right (0 ** 0 ** Start) = replay []</code>. This proof will be run at each compilation, we can’t ship our code if this is not true anymore.</p>
<p>What would happen if the proof didn’t stand?</p>
<p>Let’s try and change the type of <code>replayEmptyListGivesStart</code> with the following: <code>replayEmptyListGivesStart : Left Player1 = replay []</code></p>
<p>We obtain this error message:</p>
<pre><code>/Users/biri/Perso/katas/Tennis/TennisDT.idr:133:29-32:
    |
133 | replayEmptyListGivesStart = Refl
    |                             ~~~~
When checking right hand side of replayEmptyListGivesStart with expected type
        Left Player1 = replay []

Type mismatch between
        Right (0 ** 0 ** Start) = Left Player1 (Expected type)
and
        x = x (Type of Refl)

Specifically:
        Type mismatch between
                Left Player1Unification failure
        and
                Right (0 ** 0 ** Start)</code></pre>
<p>The compiler complains that we provide an element of type <code>x = x</code> while it was able to compute <code>Left Player1 = Right (0 ** 0 ** Start)</code>. The output is quite precise about what went wrong here.</p>
<p>Similarly, we can test some specific results of our display function:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">displayStartIsLove</span> <span class="ot">:</span> <span class="st">&quot;love&quot;</span> <span class="fu">=</span> displayScore <span class="dt">Start</span>
displayStartIsLove <span class="fu">=</span> <span class="dt">Refl</span>

<span class="fu">display1stWinnerGot15</span> <span class="ot">:</span> (s <span class="ot">:</span> <span class="dt">Score</span> <span class="dv">1</span> <span class="dv">0</span>) <span class="ot">-&gt;</span> <span class="st">&quot;15 - 0&quot;</span> <span class="fu">=</span> displayScore s
display1stWinnerGot15 <span class="fu">_</span> <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<h2 id="property-testing">Property testing</h2>
<p>Let’s now test that our replay function got a love game right. A love game happens when a player won the 4 first points in a row, ending the game without leaving any point to their opponent.</p>
<p>Let write a simple function to test this:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">testLoveGame</span> <span class="ot">:</span> <span class="dt">Left</span> p <span class="fu">=</span> (p <span class="ot">:</span> <span class="dt">Player</span>) <span class="ot">-&gt;</span> replay (replicate <span class="dv">4</span> p)</code></pre></div>
<p>Given any player, we can prove that this player won the game when he or she won the 4 first points A first try to implement this function might be:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">testLoveGame</span> <span class="ot">:</span> (p <span class="ot">:</span> <span class="dt">Player</span>) <span class="ot">-&gt;</span> <span class="dt">Left</span> p <span class="fu">=</span> replay (replicate <span class="dv">4</span> p)
testLoveGame p <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>Unfortunately, it doesn’t work. And I won’t provide you the error here, because it’s quite (very) verbose. The problem is that without knowing the value of <code>p</code> (the wining player), the compiler isn’t able to reduce the left term of the equality. Fortunately, splitting cases for the different values of <code>Player</code> is enough:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">testLoveGame</span> <span class="ot">:</span> (p <span class="ot">:</span> <span class="dt">Player</span>) <span class="ot">-&gt;</span> <span class="dt">Left</span> p <span class="fu">=</span> replay (replicate <span class="dv">4</span> p)
testLoveGame <span class="dt">Player1</span> <span class="fu">=</span> <span class="dt">Refl</span>
testLoveGame <span class="dt">Player2</span> <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>Knowing the value of <code>p</code>, the compiler is now able to reduce the left term up to <code>Left p</code>, and thus to typecheck.</p>
<p>With the same strategy, we can check more advance properties, like ensuring that one player can’t win from deuce or that one player win if scores two times after a deuce:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">testCantWinFromDeuce</span> <span class="ot">:</span> (p <span class="ot">:</span> <span class="dt">Player</span>) <span class="ot">-&gt;</span> <span class="dt">True</span> <span class="fu">=</span> isRight (replay (take <span class="dv">11</span> <span class="fu">$</span> cycle [p, opponent p]))
testCantWinFromDeuce <span class="dt">Player1</span> <span class="fu">=</span> <span class="dt">Refl</span>
testCantWinFromDeuce <span class="dt">Player2</span> <span class="fu">=</span> <span class="dt">Refl</span>

<span class="fu">gainWith2PointsFromDeuce</span> <span class="ot">:</span> (p <span class="ot">:</span> <span class="dt">Player</span>) <span class="ot">-&gt;</span> <span class="dt">Left</span> p <span class="fu">=</span> replay ((take <span class="dv">10</span> <span class="fu">$</span> cycle [<span class="dt">Player1</span>, <span class="dt">Player2</span>]) <span class="fu">&lt;+&gt;</span> replicate <span class="dv">2</span> p)
gainWith2PointsFromDeuce <span class="dt">Player1</span> <span class="fu">=</span> <span class="dt">Refl</span>
gainWith2PointsFromDeuce <span class="dt">Player2</span> <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<h2 id="property-testing-with-recursions">Property testing with recursions</h2>
<p>In the last examples, we used a arbitrary number as a parameter for <code>take</code>. Unfortunately, for these examples, testing the property for every number of points is bit complex. To illustrate how we can prove things on natural, let’s move to the <code>display</code> function again.</p>
<p>We will need a few helpers first, that are not in the base library:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">compareToSuccIsLT</span> <span class="ot">:</span> (x <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> <span class="dt">LT</span> <span class="fu">=</span> compare x (<span class="dt">S</span> x)
compareToSuccIsLT <span class="dt">Z</span> <span class="fu">=</span> <span class="dt">Refl</span>
compareToSuccIsLT (<span class="dt">S</span> k) <span class="fu">=</span> compareToSuccIsLT k

<span class="fu">compareSameIsEq</span> <span class="ot">:</span> (x <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> <span class="dt">EQ</span> <span class="fu">=</span> compare x x
compareSameIsEq <span class="dt">Z</span> <span class="fu">=</span> <span class="dt">Refl</span>
compareSameIsEq (<span class="dt">S</span> k) <span class="fu">=</span> compareSameIsEq k

<span class="fu">compareToPredIsGT</span> <span class="ot">:</span> (x <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> <span class="dt">GT</span> <span class="fu">=</span> compare (<span class="dt">S</span> x) x
compareToPredIsGT <span class="dt">Z</span> <span class="fu">=</span> <span class="dt">Refl</span>
compareToPredIsGT (<span class="dt">S</span> k) <span class="fu">=</span> compareToPredIsGT k

<span class="dt">LTnotEQ</span> <span class="ot">:</span> (<span class="dt">LT</span> <span class="fu">=</span> <span class="dt">EQ</span>) <span class="ot">-&gt;</span> <span class="dt">Void</span>
<span class="dt">LTnotEQ</span> <span class="dt">Refl</span> <span class="kw">impossible</span>

<span class="dt">LTnotGT</span> <span class="ot">:</span> (<span class="dt">Prelude</span><span class="fu">.</span><span class="dt">Interfaces</span><span class="fu">.</span><span class="dt">LT</span> <span class="fu">=</span> <span class="dt">GT</span>) <span class="ot">-&gt;</span> <span class="dt">Void</span>
<span class="dt">LTnotGT</span> <span class="dt">Refl</span> <span class="kw">impossible</span>

<span class="dt">EQnotGT</span> <span class="ot">:</span> (<span class="dt">EQ</span> <span class="fu">=</span> <span class="dt">GT</span>) <span class="ot">-&gt;</span> <span class="dt">Void</span>
<span class="dt">EQnotGT</span> <span class="dt">Refl</span> <span class="kw">impossible</span>

<span class="dt">DecEq</span> <span class="dt">Ordering</span> <span class="kw">where</span>
  decEq <span class="dt">LT</span> <span class="dt">LT</span> <span class="fu">=</span> <span class="dt">Yes</span> <span class="dt">Refl</span>
  decEq <span class="dt">LT</span> <span class="dt">EQ</span> <span class="fu">=</span> <span class="dt">No</span> <span class="dt">LTnotEQ</span>
  decEq <span class="dt">LT</span> <span class="dt">GT</span> <span class="fu">=</span> <span class="dt">No</span> <span class="dt">LTnotGT</span>
  decEq <span class="dt">EQ</span> <span class="dt">LT</span> <span class="fu">=</span> <span class="dt">No</span> (negEqSym <span class="dt">LTnotEQ</span>)
  decEq <span class="dt">EQ</span> <span class="dt">EQ</span> <span class="fu">=</span> <span class="dt">Yes</span> <span class="dt">Refl</span>
  decEq <span class="dt">EQ</span> <span class="dt">GT</span> <span class="fu">=</span> <span class="dt">No</span> <span class="dt">EQnotGT</span>
  decEq <span class="dt">GT</span> <span class="dt">LT</span> <span class="fu">=</span> <span class="dt">No</span> (negEqSym <span class="dt">LTnotGT</span>)
  decEq <span class="dt">GT</span> <span class="dt">EQ</span> <span class="fu">=</span> <span class="dt">No</span> (negEqSym <span class="dt">EQnotGT</span>)
  decEq <span class="dt">GT</span> <span class="dt">GT</span> <span class="fu">=</span> <span class="dt">Yes</span> <span class="dt">Refl</span></code></pre></div>
<p>The helpers give us two things:</p>
<ol style="list-style-type: decimal">
<li>the result of a comparison of a natural with it’s predecessor, itself, its successor;</li>
<li>a structural proof of equality/difference between two <code>Ordering</code></li>
</ol>
<p>With these helpers, we will prove the display of advantages and deuce when a player is at most one point ahead of their opponent and each player has at least scored 3 times. To do so, we must find an implementation for these 3 functions:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">displayDeuce</span> <span class="ot">:</span> (x <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> (s <span class="ot">:</span> <span class="dt">Score</span> (<span class="dv">3</span> <span class="fu">+</span> x) (<span class="dv">3</span> <span class="fu">+</span> x)) <span class="ot">-&gt;</span> displayScore s <span class="fu">=</span> <span class="st">&quot;deuce&quot;</span>
<span class="fu">displayAdvantageP1</span> <span class="ot">:</span> (x <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> (s <span class="ot">:</span> <span class="dt">Score</span> (<span class="dt">S</span> (<span class="dv">3</span> <span class="fu">+</span> x)) (<span class="dv">3</span> <span class="fu">+</span> x)) <span class="ot">-&gt;</span> displayScore s <span class="fu">=</span> <span class="st">&quot;advantage Player1&quot;</span>
<span class="fu">displayAdvantageP2</span> <span class="ot">:</span> (x <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> (s <span class="ot">:</span> <span class="dt">Score</span> (<span class="dv">3</span> <span class="fu">+</span> x) (<span class="dt">S</span> (<span class="dv">3</span> <span class="fu">+</span> x))) <span class="ot">-&gt;</span> displayScore s <span class="fu">=</span> <span class="st">&quot;advantage Player2&quot;</span></code></pre></div>
<p>I’m detailing the first one here, the two others follow a similar pattern and are left as exercises to the reader. If you look back at <code>display</code>, you can notice that we don’t use the value of the score, only its type is used to compute the display. As a consequence, we don’t need to decompose score. Let’s try with what we’ve learned so far and decompose the first parameter:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">displayDeuce</span> <span class="ot">:</span> (x <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> (s <span class="ot">:</span> <span class="dt">Score</span> (<span class="dv">3</span> <span class="fu">+</span> x) (<span class="dv">3</span> <span class="fu">+</span> x)) <span class="ot">-&gt;</span> displayScore s <span class="fu">=</span> <span class="st">&quot;deuce&quot;</span>
displayDeuce <span class="dt">Z</span> <span class="fu">_</span> <span class="fu">=</span> <span class="dt">Refl</span>
displayDeuce (<span class="dt">S</span> k) <span class="fu">_</span> <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>Of course, we can’t decompose the parameter for all the possible naturals. So we use the decomposition for each possible constructors. Unfortunately, it’s not that easy. Here is the error we obtain with this try:</p>
<pre><code>Type mismatch between
        &quot;deuce&quot; = &quot;deuce&quot; (Type of Refl)
and
        case Prelude.Nat.Nat implementation of Prelude.Interfaces.Ord, method compare n
                                                                                      n of
          LT =&gt; &quot;advantage Player2&quot;
          EQ =&gt; &quot;deuce&quot;
          GT =&gt; &quot;advantage Player1&quot; =
        &quot;deuce&quot; (Expected type)</code></pre>
<p>The compiler is not able to reduce <code>compare</code>. Here is the tricky part. The solution is thus to match against the result of compare, using a <code>with</code> rule:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">displayDeuce</span> <span class="ot">:</span> (x <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> (s <span class="ot">:</span> <span class="dt">Score</span> (<span class="dv">3</span> <span class="fu">+</span> x) (<span class="dv">3</span> <span class="fu">+</span> x)) <span class="ot">-&gt;</span> displayScore s <span class="fu">=</span> <span class="st">&quot;deuce&quot;</span>
displayDeuce <span class="dt">Z</span> <span class="fu">_</span> <span class="fu">=</span> <span class="dt">Refl</span>
displayDeuce (<span class="dt">S</span> k) s <span class="kw">with</span> (compare k k) <span class="kw">proof</span> p
  displayDeuce (<span class="dt">S</span> k) s <span class="fu">|</span> <span class="dt">LT</span> <span class="fu">=</span> <span class="ot">?lt_case</span>
  displayDeuce (<span class="dt">S</span> k) s <span class="fu">|</span> <span class="dt">EQ</span> <span class="fu">=</span> <span class="dt">Refl</span>
  displayDeuce (<span class="dt">S</span> k) s <span class="fu">|</span> <span class="dt">GT</span> <span class="fu">=</span> <span class="ot">?gt_case</span></code></pre></div>
<p>While we know that <code>compare k k</code> will always return <code>EQ</code>, the compiler has no way to figure it out. For the <code>EQ</code> case, knowing the result allows the compiler to achieve the reduction and we can conclude with <code>Refl</code>. The <code>LT</code> case and the <code>GT</code> case are symmetric. In both case, we have to prove that the case can’t happen.</p>
<p>Here is the information we have for <code>?lt_case</code>:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">  <span class="fu">k</span> <span class="ot">:</span> <span class="dt">Nat</span>
  <span class="fu">s</span> <span class="ot">:</span> <span class="dt">Score</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> k)))) (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> k))))
  <span class="fu">p</span> <span class="ot">:</span> <span class="dt">LT</span> <span class="fu">=</span>
      <span class="dt">Prelude</span><span class="fu">.</span><span class="dt">Nat</span><span class="fu">.</span><span class="dt">Nat</span> implementation <span class="kw">of</span> <span class="dt">Prelude</span><span class="fu">.</span><span class="dt">Interfaces</span><span class="fu">.</span><span class="dt">Ord</span>, method compare k
                                                                               k
<span class="co">--------------------------------------</span>
<span class="fu">lt_Case</span> <span class="ot">:</span> <span class="st">&quot;advantage Player2&quot;</span> <span class="fu">=</span> <span class="st">&quot;deuce&quot;</span></code></pre></div>
<p>So we need to find an element of type <code>&quot;advantage Player2&quot; = &quot;deuce&quot;</code> with a context that contains one very interesting element: <code>p</code> that is a “proof” that <code>LT = compare k k</code></p>
<p>When you want to prove that something is not possible, you basically want to obtain a value of type <code>Void</code> and then conclude with the <code>void</code> function, that can build any type out of <code>Void</code>. <code>Void</code> is the bottom type, the one that is uninhabited. We have already some element to build such type. <code>LTisNotEQ</code> that we have introduced earlier, is of type <code>Not (LT = EQ)</code>. This type is actually an alias for <code>LT = EQ -&gt; Void</code>. And with <code>p</code>, we’re almost there, we just need to replace <code>compare k k</code> with it’s true value, <code>EQ</code>, we’re just one rewriting rule away. With the same reasoning for the GT case we obtain the following code for <code>displayDeuce</code>:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">displayDeuce</span> <span class="ot">:</span> (x <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> (s <span class="ot">:</span> <span class="dt">Score</span> (<span class="dv">3</span> <span class="fu">+</span> x) (<span class="dv">3</span> <span class="fu">+</span> x)) <span class="ot">-&gt;</span> displayScore s <span class="fu">=</span> <span class="st">&quot;deuce&quot;</span>
displayDeuce <span class="dt">Z</span> <span class="fu">_</span> <span class="fu">=</span> <span class="dt">Refl</span>
displayDeuce (<span class="dt">S</span> k) s <span class="kw">with</span> (compare k k) <span class="kw">proof</span> p
  displayDeuce (<span class="dt">S</span> k) s <span class="fu">|</span> <span class="dt">LT</span> <span class="fu">=</span> void (<span class="dt">LTnotEQ</span> (<span class="kw">rewrite</span> compareSameIsEq k <span class="kw">in</span> p))
  displayDeuce (<span class="dt">S</span> k) s <span class="fu">|</span> <span class="dt">EQ</span> <span class="fu">=</span> <span class="dt">Refl</span>
  displayDeuce (<span class="dt">S</span> k) s <span class="fu">|</span> <span class="dt">GT</span> <span class="fu">=</span> void (negEqSym <span class="dt">EQnotGT</span> (<span class="kw">rewrite</span> compareSameIsEq k <span class="kw">in</span> p))</code></pre></div>
<p>And here we go, it compiles and we have proven that if each player have scored at least 3 points and have the same number of points, their score will be “deuce”.</p>
<p>This short example also shows the limit of using types as tests. You’re doing more than testing, you are proving facts, which means that you must assist the compiler to find its way through the code to build the proof.</p>
<h1 id="a-few-hints">A few hints</h1>
<p>Let’s recap some of useful hint if you want to use types as tests:</p>
<ol style="list-style-type: decimal">
<li>Unit tests are the easiest, as most of the time, the compiler will be able to reduce the full expression if you provide all the required values.</li>
<li>When you do property testing (proving actually), you almost always have to split cases for the variables, to ease the progression of the computer.</li>
<li>When the compiler cannot reduce a value, help him with rewrite rules. Sometimes, it may be useful to tweak your test a bit to ease the reduction of a formula. For example, <code>(x : Nat) -&gt; (s : Score (3 + x) (3 + x)) -&gt; &quot;deuce&quot; = displayScore s</code> is easier to prove than <code>(x : Nat) -&gt; (s : Score (x + 3) (x + 3)) -&gt; &quot;deuce&quot; = displayScore s</code> because of the implementation of <code>(+)</code> for Natural.</li>
<li>The error messages will help you figure out where the compiler is stuck and what expressions should be rewritten.</li>
<li>If the compiler explores cases that are not possible, help it figure it out by producing a <code>Void</code> value.</li>
</ol>
<p>I hope this helps. Unit testing is usually as easy with types than with traditional test functions, and property testing is usually harder, as it requires you to build a proof rather than just running the test on a limited set of values.</p>
<p>Have fun coding.</p>
<h1 id="acknowledgments">Acknowledgments</h1>
<p>I would like to thanks the <a href="http://lambdada.org">Lambdada</a> community, who helped me to figure out how great the tests as type feature is, have heard the first version of my explanations and made some remarks to improve the code.</p>
<p>This blog has no comments, for any question or remark, feel free to contact me on <a href="https://twitter.com/BeRewt">twitter</a>.</p>
]]></description>
    <pubDate>Sat, 19 May 2018 00:00:00 UT</pubDate>
    <guid>http://nicolas.biri.name//posts/2018-05-19-Dependent-types-as-tests.html</guid>
    <dc:creator>Nicolas Biri</dc:creator>
</item>
<item>
    <title>Le cas Facebook en détail</title>
    <link>http://nicolas.biri.name//posts/2016-08-20-Le-cas-Facebook-en-detail.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 20, 2016
    
        by Nicolas Biri
    
</div>

<p>Le <a href="http://nicolas.biri.name/posts/2016-08-17-Ne-plus-etre-un-produit.html">précédent billet</a> était une réaction agacée, à chaud, à une <a href="https://www.laquadrature.net/fr/si-vous-etes-le-produit">tribune mensongère et contre-productive</a> de la Quadrature du Net. Je sais, ce n’est pas la Quadrature dans son entièreté qui a porté cette tribune mais elle l’héberge et à ma connaissance, personne là bas n’a semblé trouver à redire sur les arguments de ce texte, je les associe de bon cœur.</p>
<p>Comme visiblement certains n’ont pas compris (et j’avoue que le titre mal choisi n’aidait pas), que mon but n’était pas de faire une critique ou une dithyrambe profonde du modèle de Facebook, je propose de le faire ici, histoire de poser les choses. Au passage, ça permettra d’expliciter quelles sont les arguments qui, à mes yeux, sont valables pour critiquer Facebook. En effet, il parait que l’on ne peut critiquer que si on a quelque chose à proposer. D’ailleurs, tant qu’on parle de cela, je rappelle à toute critique cinéma que la prochaine fois qu’il di du mal d’un film, ça serait bien qu’il propose un court métrage comme contre proposition.</p>
<h1 id="les-vérités-pénibles">Les vérités pénibles</h1>
<p>Je ne vais pas refaire l’intégralité de mon précédent billet ici mais reprenons les principaux éléments qui m’ont agacés dans le billet publié par la Quadrature.</p>
<h2 id="facebook-rend-un-service-à-ses-utilisateurs">Facebook rend un service à ses utilisateurs</h2>
<p>L’occulter et ne présenter que le gain que Facebook tire des données que ses utilisateurs y laissent (ce que sous entend, au bas mot, le terme de voleur) est un biais énorme. Soit c’est fait sciemment, auquel cas on essaie de tromper ses lecteurs. Soit l’auteur n’en a pas conscience et c’est une incompréhension majeure des internautes qu’il souhaite défendre. Je ne dis pas que chacun doit estimer que ce que permet Facebook est utile pour lui. Libre à chacun de douter de ce que ses services pourraient lui apporter personnellement. En revanche, il me semble difficile de nier que beaucoup trouvent les services proposés suffisamment intéressants pour tenir les utiliser régulièrement.</p>
<h2 id="il-est-normal-que-facebook-lutte-contre-le-blocage-de-la-publicité">Il est normal que Facebook lutte contre le blocage de la publicité</h2>
<p>Trouver totalement normal que les internautes puissent utiliser des moyens légaux pour contourner la publicité mais être choquer que les compagnies vivant de la publicité tentent de déjouer ces moyens est là aussi un point de vue stupide. Je comprends que ces tentatives (que l’on parle de celle de Facebook ou de celles de plusieurs sites d’informations) agacent. Elles sont néanmoins totalement logiques et fondées. Il est normal pour un acteur commercial d’utiliser les moyens légaux à sa disposition pour tenter de pérenniser ses profits.</p>
<h1 id="les-mauvaises-raisons-pour-utiliser-un-ad-blocker">Les mauvaises raisons pour utiliser un ad-blocker</h1>
<p>En substance, le message à Facebook du billet de la Quadrature était : “il est normal que l’on puisse utiliser un ad-blocker si l’on n’est pas en phase avec votre modèle publicitaire.” Encore une fois, dans ce dont il est question ici, Facebook ne remet pas en cause cet usage, il cherche à le contourner légalement. Croyez bien que si l’article avait été sur le sujet de “Facebook cherche à interdire les bloqueurs de publicité”, ma réaction aurait été différente.</p>
<p>Mais réfléchissons un peu à la logique d’utiliser Facebook avec un bloqueur de publicité. L’auteur explique que ça ne remet pas en cause la santé financière de Facebook. Il a raison, ça ne la compromettrait que si tout le monde arrivait, efficacement, à bloquer ses publicités. Il est amusant qu’après mon premier billet sur le sujet, on m’aie reproché un point de vue de “sachant”. Admettons. Promouvoir l’utilisation d’un service sans accepter la contrepartie publicitaire, modèle uniquement viable parce que d’autres l’acceptent ou ne savent pas comment se passer de la publicité, ce ne serait pas également un point de vue de sachant ?</p>
<p>En continuant à utiliser un service (notamment un service communautaire) avec un ad-blocker, alors que vous savez parfaitement que vous ne l’utiliseriez pas sinon, vous renforcez ce service, l’intérêt que ceux qui n’utilisent pas ce service ont à l’utiliser et donc vous mettez ceux qui ne connaissent pas les bloqueurs de publicité dans une situation encore plus confortable. Votre sollicitude à l’égard des non-sachants me touche.</p>
<h1 id="la-critique-de-facebook">La critique de Facebook</h1>
<p>N’ayant pas parler de ce qui me gêne dans le fonctionnement de Facebook la dernière fois, on m’a taxé de simplisme ou de défendre Facebook. Alors soit, ne nous contentons pas de critiquer les mauvais arguments et proposons quelques axes de critiques non exhaustifs.</p>
<h2 id="le-pistage-hors-du-site">Le pistage hors du site</h2>
<p>Si j’estimais normal qu’un utilisateur de Facebook doive avoir conscience que les données qu’il y partage soient utilisées par le site (même s’il peut être bon de le rappeler de façon non-biaisée). Je trouve bien moins normal que Facebook piste les mouvements des internautes (utilisateurs <strong>ou non</strong>) pour monétiser son activité. En effet, losrsque je suis sur Facebook, je sais (ou devrais savoir) que ce que je fais lui est connu. Lorsque je visite un site tiers ayant un lien (parfois minime) avec Facebook, c’est bien moins le cas. L’acceptation implicite des conditions d’utilisation dont je parlais dans le billet précédent n’est plus de mise ici.</p>
<p>Tout le monde a dû voir ce message pénible et obligatoire indiquant l’utilisation de cookies sur la plupart des sites web. Ce qui est fortement ignoré, c’est que les cookies en questions ne sont pas uniquement ceux du site visités, mais également potentiellement tous ceux des sites qui sont intégrés au contenu du dit site.</p>
<p>Prenons un exemple : je visite mon site de jeux de société préféré et celui-ci intègre sur sa page un bouton pour “partager le contenu sur Facebook”. Ce bouton est fourni par Facebook et le simple fait de l’afficher permet à Facebook de savoir que vous avez visité cette page.</p>
<p>Cette pratique est légale, oui, mais fortement critiquable. Ce modèle, consistant à pister les gens de manière cachée, même lorsqu’ils ne sont pas sur votre site, est certainement le point le plus important à dénoncer dans la monétisation des profils des internautes (et en terme de confidentialité des données personnelles.)</p>
<p>Pour autant, même avec cet argument (qui me fait avoir très peu de considération pour Facebook), je ne les traiterai pas de voleur, parce que ce n’est pas le cas.</p>
<h2 id="les-autres-pistes">Les autres pistes ?</h2>
<p>Facebook est critiquable sur sa diligence à bloquer ses utilisateurs pour (un peu) de nudité alors qu’il est moins rapide à bloquer des contenus haineux. Ou à sa volonté de bloquer certains contenus pour éviter d’être mal vus de certains pouvoir. Je comprends que ça puisse être choqué et dénoncé. Pour ma part, c’est juste une bonne raison de ne pas utiliser leur service car après tout, c’est le meilleur moyen pour lutter contre eux.</p>
<p>Il y a certainement d’autres critiques légitimes, je n’ai pas envie de creuser, il y a déjà là suffisamment pour ne pas utiliser des arguments fallacieux.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Voilà, avec un peu plus de calme, des arguments plus étayés de ce qui m’a énervé dans cette tribune de la Quadrature. Estimez maintenant si, en relisant cette tribune, l’avis qui y est porté propose des arguments valides et s’il touche au but ou non. Vous connaissez mon avis, faites vous le votre.</p>
<p>Ce genre de divergence est la raison principale qui fait que je n’apprécie pas la Quadrature du Net. Leur envie de dénoncer un système, souvent à juste titre, leur fait parfois utiliser des arguments fallacieux ou renier certains principes qui me sont importants.</p>
]]></description>
    <pubDate>Sat, 20 Aug 2016 00:00:00 UT</pubDate>
    <guid>http://nicolas.biri.name//posts/2016-08-20-Le-cas-Facebook-en-detail.html</guid>
    <dc:creator>Nicolas Biri</dc:creator>
</item>
<item>
    <title>Ne plus être le produit</title>
    <link>http://nicolas.biri.name//posts/2016-08-17-Ne-plus-etre-un-produit.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 17, 2016
    
        by Nicolas Biri
    
</div>

<p>Aujourd’hui, sur ma timeline twitter, a circulé un article de la Quadrature intitulé “<a href="https://www.laquadrature.net/fr/si-vous-etes-le-produit">Si vous êtes le produit, ce n’est pas gratuit</a>”. Je suis très souvent critique sur la forme des prises de positions de la quadrature, que je trouve trop souvent enfermée dans une opposition caricaturale. Cet article est pire, car il est rempli d’arguments que je trouve, faux, injustes et mensongers. Du coup, je prends le temps d’expliquer pourquoi.</p>
<h1 id="le-modèle-commercial-gratuit">Le modèle commercial “gratuit”</h1>
<p>La premier partie, très juste, critique le mantra “si c’est gratuit, c’est vous le produit” et propose d’y substituer le plus juste “si vous êtes le produit, ce n’est pas gratuit”.</p>
<p>Jusque là, tout va bien.</p>
<p>Et là, à peine plus loin, on commence à s’éloigner de ce que je juge pertinent :</p>
<blockquote>
<p>vous acceptez des contrats d’utilisation léonins qui font de vous une main d’œuvre sans droit ni titre, vous acceptez d’être pistés, tracés, traqués pour que le client final (généralement une régie publicitaire) sache tout de vous pour mieux vous cibler.</p>
</blockquote>
<p>Le choix du vocabulaire fait tout pour placer le consommateur de services monétisant le contenu de ses utilisateurs et vivant de la publicité comme une victime. Je comprends que l’on rappelle quel est le mode de fonctionnement de ces sociétés, la limitation des droits que le contrat d’utilisation implique.</p>
<p>Il est toutefois important de rappeler que beaucoup, en conscience, acceptent ces contraintes. Parce qu’ils estiment que la contrepartie fait que l’accord est bon. Prenons mon cas, je suis un gros utilisateur de Twitter, service commercial qui utilise le contenu que je publie pour déterminer quelles publicités peuvent m’intéresser et qui a droit de vie et de mort sur mon compte. Je le sais et je l’accepte. Et je ne me sens ni traqué, ni ciblé, ni signataire d’un contrat léonins.</p>
<p>Il y a, chez les défenseurs des libertés, une volonté de convaincre les gens qu’il ne <strong>faut</strong> pas utiliser ces services qui m’a toujours gêné.</p>
<h1 id="lescroquerie-de-laccusation-de-vol">L’escroquerie de l’accusation de vol</h1>
<p>Continuons avec une instance de service qui monétise les données de ses utilisateurs avec l’exemple de Facebook. Je me permets de recopier complètement le passage concerné :</p>
<blockquote>
<p>Dans une conférence d’il y a longtemps, j’expliquais que Facebook était le plus grand voleur que je connaisse. Pour résumer : Facebook publie vos contenus (sans vous payer) pour attirer du public vers les écrans de publicité qu’il vend. Il revend (sans les payer) vos données personnelles à ses clients (les régies publicitaires) pour qu’elles puissent mieux vous cibler. Puis il vous propose – à vous – de payer pour que vos contenus soient plus visibles que les autres (et donc pour attirer plus de visiteurs vers les écrans de pub de ses clients), avant finalement de vous proposer d’acheter ses actions pour espérer enfin toucher une part du fric que votre travail rapporte.</p>
</blockquote>
<p>C’est là que je me suis dit que non, jamais je ne pourrais supporter la quadrature. Je n’aime pas Facebook, j’y ai un compte dormant mais j’utilise très peu le service. Pourtant, je peux affirmer sans crainte que tout ce passage est la charge la plus honteuse et malhonnête que j’ai pu lire sur ce service. Détaillons.</p>
<ul>
<li><q>Facebook publie vos &gt; contenus (sans vous payer) pour attirer du public vers les écrans de publicité qu’il vend.</q> : Oui, Facebook ne vous paye pas. Facebook vous rend un <em>service</em> qu’il paye avec la publicité. Ce service est de vous permettre de publier votre contenu et de le rendre disponible à vos contacts. Si vous jugez que ce service n’en vaut pas la peine, libre à vous de vous en passer.</li>
<li><q>Il revend (sans les payer) vos données personnelles à ses clients (les régies publicitaires) pour qu’elles puissent mieux vous cibler.</q> Oui. ça fait partie là aussi de la contrepartie pour le service rendu.</li>
<li></q>Il vous propose – à vous – de payer pour que vos contenus soient plus visibles que les autres.</q> Si vous payez, c’est soit que vous estimez que votre contenu est tellement intéressant qu’il doit être visible, soit que vous espérez que ça soit rentable pour vous. Dans tous les cas, si vous <em>décidez</em> de donner votre argent à Facebook, c’est que la contrepartie vous semble intéressante. On est loin du vol.</li>
</ul>
<p>Bref, parce que l’auteur ne juge pas le service intéressant par rapport ses exigences et attentes, Facebook est un voleur, le plus grand voleur. J’ai pour ma part l’impression que la contrepartie offerte par Facebook est plus intéressante que celle offerte dans toutes les histoires de vol que j’ai entendu.</p>
<p><q>Et vous en redemandez.</q> Il est toujours bon de souligner les phrases anodines qui tentent de prendre l’ascendant sur le lecteur : si vous utilisez un service qui vous vole, vous n’êtes pas bien malin.</p>
<h1 id="linjustice-des-mesures-anti-blocage">L’injustice des mesures anti-blocage</h1>
<p>Si on parle de Facebook, ce n’est pas juste pour vomir sur leur service, c’est également pour dénoncer les mesures anti-adblock prisent par le site : Facebook a visiblement depuis quelques temps modifier son code pour passer aux travers des filtres des bloqueurs de publicité.</p>
<p>Visiblement c’est choquant. Très. Plus que l’existence de logiciel qui bloquent la publicité. Laissons de coté pour le moment ce que je pense de la publicité sur internet. Si on trouve normal que les gens essaient de ne pas afficher les publicités, ne doit-on pas trouver également normal que les sites dont c’est le fond de commerce essaient d’être plus malin qu’eux ? Je dirais que si, mais je ne suis pas un expert des libertés (car visiblement, c’est de ça dont il s’agit.)</p>
<p>Ce préambule mis en place, regardons ce que l’article nous dit du modèle de la publicité sur internet. <q>Elle est devenue envahissante au point d’avoir suscité l’émergence des dits ad-blockers.</q> C’est un point de vue. On peut aussi juger que ce qui a popularisé les ad-blockers, c’est la volonté de continuer à utiliser des sites dont on ne supportait pas la logique commerciale. Le dire comme ça, c’est malheureusement culpabiliser l’utilisateur plutôt que le site et ça ne nous arrange pas. C’est donc mal.</p>
<p><q>le modèle économique « publicité contre fausse gratuité » est devenu tel qu’il remet en cause un tas de libertés fondamentales.</q> Et c’est reparti.</p>
<p><q>La liberté d’expression (il faut que l’espace publicitaire reste assez propre pour attirer les annonceurs, cachez ce sein qu’ils ne sauraient voir).</q> Alors autant je trouve la censure de Facebook, entre autres, ridicule, autant y associer la liberté d’expression me troue le cul. Donc non, on ne publie pas sur un site tiers ce qu’on veut, ça fait là aussi partie du compromis que l’on accepte en utilisant le service. Oui, je trouve honteux que Facebook soit choqué par l’érotisme. Mais je le sais, c’est connu et ce n’est pas une putain d’entrave à la liberté d’expression. Un nichon qui est censuré par facebook aura sa place dans plein d’autres endroit du web. Je trouve également cocasse d’estimer que ne pas pouvoir publier sur Facebook est synonyme d’entrave à la liberté d’expression, c’est donner beaucoup de pouvoir à un site qui est le plus grand des voleurs.</p>
<h1 id="les-ad-blocks-et-la-pause-pipi">Les ad-blocks et la pause pipi</h1>
<p>Le coup de grâce, dans ce tombereau d’inepties, vient quand on finit par comparer un ad-blocker à une pause pipi devant la télé. Pas le pire, certes, mais la fatigue aidant, un argument à la con en plus passe mal. Il s’agit tout d’abord de comparer internent, un média essentiellement écrit (surtout avec l’exemple cité de Facebook), à un média exclusivement vidéo. Ensuite, quand vous allez aux toilettes, la publicité passe quand même, pas quand vous la bloquez. Enfin, la télévision à plein d’astuces pour vous incitez à regarder la publicité (coupure avant un moment crucial, mini pause par exemple.) Il n’y a pas de comparaison sur internet… Ah si, contourner l’ad-blocker, cette idée même qui choque l’auteur.</p>
<h1 id="ma-relation-à-la-publicité-sur-internet">Ma relation à la publicité sur internet</h1>
<p>Je n’utilise plus d’ad-blocker depuis plusieurs années, j’utilise uniquement un tracker (<a href="https://www.ghostery.com">ghostery</a>), pour éviter aux sites de me pister.</p>
<p>Je n’utilise pas d’ad-blocker parce que j’estime que si je visite un site, je me dois d’accepter le contrat implicite qui me lie à ce site. De plus, cela à un gros avantage : si un site place trop de publicité, je m’en rends compte et j’arrête de m’y rendre. C’est la façon la plus saine pour ne pas encourager des pratiques commerciales qu’on désapprouve.</p>
<p>En revanche, j’utilise un outil anti-tracking car si j’accepte le contrat implicite qui me lie au site que je visite, je refuse d’accepter celui des sites qu’il intègre si je ne décide pas explicitement de les visiter.</p>
<p>Il est peut-être important vu la teneur de ce qui précède de bien souligner qu’il s’agit de ma façon d’interagir, pas de ce que j’estime nécessaire que tout le monde fasse.</p>
]]></description>
    <pubDate>Wed, 17 Aug 2016 00:00:00 UT</pubDate>
    <guid>http://nicolas.biri.name//posts/2016-08-17-Ne-plus-etre-un-produit.html</guid>
    <dc:creator>Nicolas Biri</dc:creator>
</item>
<item>
    <title>Union Type in Idris (Part 5)</title>
    <link>http://nicolas.biri.name//posts/2016-08-14-union-type-in-idris-part-5.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 14, 2016
    
        by Nicolas Biri
    
</div>

<p>Go back to the <a href="http://nicolas.biri.name/posts/2016-07-26-union-type-in-idris-part-1.html">first part</a>.</p>
<h1 id="unit-and-property-testing-in-idris">Unit and property testing in Idris</h1>
<p>I thought I was done with the union type series, but then I think about how great this example is to demonstrate some of the possibilities of test and property checking in Idris.</p>
<p>Idris has a <a href="http://docs.idris-lang.org/en/latest/tutorial/testing.html">basic testing framework</a>. I won’t discuss it here. As Idris is very young, the framework has little interest at this time and we can do way better (in my opinion) by just using types in a clever way.</p>
<h2 id="unit-testing-at-compile-time">Unit testing at compile time</h2>
<p>As types are a first class language construct in Idris, you can use value to build type. An interesting type constructor is <code>=</code>. The type <code>a = b</code> is populated by the proof that <code>a</code> is euqal to be <code>b</code>. To construct inhabitants of this class, we often use <code>Refl</code>, which is an inhabitant of <code>a = a</code> (We already used Refl in the definitions of isomorphisms in <a href="http://nicolas.biri.name/posts/2016-08-14-union-type-in-idris-part-4.html">part 4</a>.)</p>
<p>This can be used to define unit testing functions, that will be resolved at compile time. If we go back to the definition of <code>Union</code> and ot the <code>member</code> constructor</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Union</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">MemberHere</span> <span class="ot">:</span> ty <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>ts)
  <span class="dt">MemberThere</span> <span class="ot">:</span> <span class="dt">Union</span> ts <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>ts)

<span class="fu">member</span> <span class="ot">:</span> ty <span class="ot">-&gt;</span> {<span class="kw">auto</span> e<span class="ot">:</span> <span class="dt">Elem</span> ty ts} <span class="ot">-&gt;</span> <span class="dt">Union</span> ts
member x {e <span class="fu">=</span> <span class="dt">Here</span>} <span class="fu">=</span> <span class="dt">MemberHere</span> x
member x {e <span class="fu">=</span> <span class="dt">There</span> later} <span class="fu">=</span>
  <span class="dt">MemberThere</span> (member x {e <span class="fu">=</span> later})</code></pre></div>
<p>We can quickly set up some tests:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">memberCreateMemberHereTest</span> <span class="ot">:</span>
  the (<span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>]) (member <span class="st">&quot;Foo&quot;</span>) <span class="fu">=</span>
  <span class="dt">MemberHere</span> <span class="st">&quot;Foo&quot;</span>
memberCreateMemberHereTest <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>and:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">memberCreateMemberThereTest</span> <span class="ot">:</span>
  the (<span class="dt">Union</span> [<span class="dt">String</span>, <span class="dt">Nat</span>]) (member <span class="dv">42</span>) <span class="fu">=</span>
  <span class="dt">MemberThere</span> (<span class="dt">MemberHere</span> <span class="dv">42</span>)
memberCreateMemberThereTest <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>These tests will be executed at compile time and will pass if our definition are correct. No need for a framework.Moreover, if we ship a faulty version without testing, thrd users won’t be able to use the library because they won’t be able to compile our code.</p>
<h1 id="theorem-proving-or-enhanced-property-testing">Theorem proving (or enhanced property testing)</h1>
<p>Tests prove that your definitions are correct for some values, theorem prove that it’s correct for all values. Even with something as simple as the <code>Union</code> library, we can prove fancy stuff.</p>
<h2 id="lets-get-a-member">Let’s <code>get</code> a <code>member</code></h2>
<p>First, let’s recall the definition of <code>get</code>:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">get</span> <span class="ot">:</span> <span class="dt">Union</span> ts <span class="ot">-&gt;</span> {<span class="kw">auto</span> p<span class="ot">:</span> <span class="dt">Elem</span> ty ts} <span class="ot">-&gt;</span> <span class="dt">Maybe</span> ty
get (<span class="dt">MemberHere</span> x)      {p <span class="fu">=</span> <span class="dt">Here</span>}      <span class="fu">=</span> <span class="dt">Just</span> x
get (<span class="dt">MemberHere</span> x)      {p <span class="fu">=</span> <span class="dt">There</span> <span class="fu">_</span>}   <span class="fu">=</span> <span class="dt">Nothing</span>
get (<span class="dt">MemberThere</span> x)     {p <span class="fu">=</span> <span class="dt">Here</span>}      <span class="fu">=</span> <span class="dt">Nothing</span>
get (<span class="dt">MemberThere</span> later) {p <span class="fu">=</span> (<span class="dt">There</span> l)} <span class="fu">=</span> get later {p <span class="fu">=</span> l}</code></pre></div>
<p>It’s quite natural to see <code>get</code> as the <em>invert</em> of <code>member</code>. Let’s formalise it with some properties.</p>
<p>To warm up, we’ll write a first one that just work for a trivial case: one type union. We want to check that if we build a one typ uninon with <code>member</code> and <code>get</code> ot back, we obtain <code>Just</code>. It’s as simple as writing this description:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">getHereMemberIsJust</span> <span class="ot">:</span> (x <span class="ot">:</span> a) <span class="ot">-&gt;</span> get (member x) <span class="fu">=</span> <span class="dt">Just</span> x
getHereMemberIsJust <span class="fu">_</span> <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>Let’s go further and prove something similar for more complex unions. To do so, we must be able to reason on <em>which type</em> we populated. To do so, we will make the <code>Elem ty ts</code> implicit parameter of <code>member</code> and <code>get</code> explicit.</p>
<p>If we create a union with <code>member</code> at a place given by <code>Elem ty ts</code> and check the value at the same place with <code>get</code>, we should have <code>Just</code> the value:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">getMemberWithElemIsJust</span> <span class="ot">:</span>
  (x <span class="ot">:</span> a) <span class="ot">-&gt;</span>
  (p <span class="ot">:</span> <span class="dt">Elem</span> a xs) <span class="ot">-&gt;</span>
  the (<span class="dt">Maybe</span> a) (get (member x {p}) {p}) <span class="fu">=</span> <span class="dt">Just</span> x</code></pre></div>
<p>This prove is trickier thant the previous one. It should be proved by induction on <code>p</code>. The base case is easy. if <code>p = Here</code>, the compiler will reduce both part of the equality by itself and we only has to prove a straight forward equality:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">getMemberWithElemIsJust <span class="fu">_</span> <span class="dt">Here</span> <span class="fu">=</span> <span class="dt">Refl</span></code></pre></div>
<p>The induction case is quite easy too now thanks to the previous case hypothesis.</p>
<p>It’s time for me to introduce the interactive proof facilities of Idris. Actually, I should have done it way earlier but it’s one of this thing that seems so natural to use that you forgot to mention how great it is.</p>
<p>The Idris REPL, and many compatible editors, provide some helpful command to ease type driven development. One of them is being able to define <em>holes</em> in your code and to check their type. More details about TDD and interactive development in Idris can be found in the <a href="http://docs.idris-lang.org/en/latest/tutorial/interactive.html">online documentation</a> or in the excellent <a href="https://www.manning.com/books/type-driven-development-with-idris">Idris book</a>.</p>
<p>Now that you know it, we can use hole in our induction case:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">getMemberWithElemIsJust x (<span class="dt">There</span> later) <span class="fu">=</span> <span class="ot">?wut</span></code></pre></div>
<p><code>?wut</code> is our hole, and if we ask to the compiler its type, we obtain:</p>
<pre><code>  a : Type
  x : a
  xs : List Type
  later : Elem a xs
  y : Type
--------------------------------------
wut : get (member x) = Just x</code></pre>
<p>Idris provides a recap of all the types in the context, and display the expected type for <code>wut</code>. With the context information, Idris was able, by itself, to reduce <code>wut</code> to the type of the induction hypothesis. Thus, we just have to provide it:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">getMemberWithElemIsJust x (<span class="dt">There</span> later) <span class="fu">=</span>
  getMemberWithElemIsJust x later</code></pre></div>
<p>And that’s it. We have a complete proof that if we put a value at a given place of a union and if we get the value at the same place, we obtain <code>Just</code> this value.</p>
<h1 id="the-difficulty-of-theorem-proving-digression">The difficulty of theorem proving (digression)</h1>
<p>The above proofs are almost trivial when you are used to types and to theorem proving. However, it may be hard to grasp for newcomers. Actually, these small examples can be used to illustrate the difficulties encountered by the advocates of formally proved code to convince developpers and the industry.</p>
<p>To be honest, I had few experiences with formal proof education to devleopers. However, during these experiences, I encountered two majors objections:</p>
<ol style="list-style-type: decimal">
<li>The properties I want to test are not complex enough to require a whole proof, proving that it works for some values, or for a set of random value is sufficient.</li>
<li>When I have to encode a proof, I have to formalize a work that I have already done mentally when I wrote the code, in a non-natural way.</li>
</ol>
<p>Both objections are unfortunately valid in most cases. We can however mitigates this feeling by:</p>
<ol style="list-style-type: decimal">
<li>What if, for almost the same costs, as unit or properties tests, you can be sure that it is valid for all the values.</li>
<li>Providing helpful enough programing environment to mae the formalisation process as natural as possible.</li>
</ol>
<p>Moreover, I should emphasize one of the major advantages of formal proof embedded in a library, that I’ve already mentioned in the article. These proofs of properties can be seen as a contract that my library ensure to respect. It offers garantees about third party code and thus can higly reduce the lack of confidence that I can have in those libraries.</p>
]]></description>
    <pubDate>Sun, 14 Aug 2016 00:00:00 UT</pubDate>
    <guid>http://nicolas.biri.name//posts/2016-08-14-union-type-in-idris-part-5.html</guid>
    <dc:creator>Nicolas Biri</dc:creator>
</item>
<item>
    <title>Union Type in Idris (Part 4)</title>
    <link>http://nicolas.biri.name//posts/2016-08-02-union-type-in-idris-part-4.html</link>
    <description><![CDATA[<div class="info">
    Posted on August  2, 2016
    
        by Nicolas Biri
    
</div>

<p>Go back to the <a href="http://nicolas.biri.name/posts/2016-07-26-union-type-in-idris-part-1.html">first part</a>.</p>
<h1 id="a-glimpe-of-equality">A glimpe of equality</h1>
<p>Idris handles equality with a typeclass, just like Haskell. Whilst equality must be define specifically for each sum type, we can define the equality in a generic manner for union types. The idea is to define the equality iteratively on the list of types of the union.</p>
<h2 id="equality-for-union-xxs">Equality for <code>Union x::xs</code></h2>
<p>Let’s start with the recursive case, do we really need to elaborate?</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris">(<span class="dt">Eq</span> ty, <span class="dt">Eq</span> (<span class="dt">Union</span> xs)) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Union</span> (ty<span class="ot">::</span>xs)) <span class="kw">where</span>
  (<span class="fu">==</span>) (<span class="dt">MemberHere</span> x) (<span class="dt">MemberHere</span> y) <span class="fu">=</span> x <span class="fu">==</span> y
  (<span class="fu">==</span>) (<span class="dt">MemberHere</span> x) (<span class="dt">MemberThere</span> y) <span class="fu">=</span> <span class="dt">False</span>
  (<span class="fu">==</span>) (<span class="dt">MemberThere</span> x) (<span class="dt">MemberHere</span> y) <span class="fu">=</span> <span class="dt">False</span>
  (<span class="fu">==</span>) (<span class="dt">MemberThere</span> x) (<span class="dt">MemberThere</span> y) <span class="fu">=</span> x <span class="fu">==</span> y</code></pre></div>
<p>We need equality for the previous union (induction) nd for the newly added type. Then, two terms are equal if they point to the same type and have the same value.</p>
<h2 id="the-base-case">The base case</h2>
<p>Things here are a little trickier. We nned an instance of <code>Eq (Union [])</code>. Let’s look back at the <code>Union</code> definition:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Union</span> <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">MemberHere</span> <span class="ot">:</span> (x<span class="ot">:</span> ty) <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>xs)
  <span class="dt">MemberThere</span> <span class="ot">:</span> (x<span class="ot">:</span> <span class="dt">Union</span> xs) <span class="ot">-&gt;</span> <span class="dt">Union</span> (ty<span class="ot">::</span>xs)</code></pre></div>
<p>Do you see the potential issue? None of them allow us to build a <code>Union []</code>. It’s impossible to build an element of <code>Union []</code>? Just explain it to Idris:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Eq</span> (<span class="dt">Union</span> []) <span class="kw">where</span>
  (<span class="fu">==</span>) (<span class="dt">MemberHere</span> <span class="fu">_</span>) <span class="fu">_</span> <span class="kw">impossible</span>
  (<span class="fu">/=</span>) (<span class="dt">MemberThere</span> <span class="fu">_</span>) <span class="fu">_</span> <span class="kw">impossible</span></code></pre></div>
<p>Profit:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">&gt;</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="st">&quot;foo&quot;</span> <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="st">&quot;foo&quot;</span>
<span class="dt">True</span> <span class="ot">:</span> <span class="dt">Boolean</span>
<span class="fu">&gt;</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="st">&quot;foo&quot;</span> <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="st">&quot;bar&quot;</span>
<span class="dt">False</span> <span class="ot">:</span> <span class="dt">Boolean</span>
<span class="fu">&gt;</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="st">&quot;foo&quot;</span> <span class="fu">=</span> the (<span class="dt">Union</span> [<span class="dt">Nat</span>, <span class="dt">String</span>]) <span class="dv">42</span>
<span class="dt">False</span> <span class="ot">:</span> <span class="dt">Boolean</span></code></pre></div>
<h2 id="uninhabited-types">Uninhabited types</h2>
<p>There is an alternative to the <code>impossible</code> solution. We can claim that a type is uninhabited thanks to a typeclass:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Uninhabited</span> (<span class="dt">Union</span> []) <span class="kw">where</span>
    uninhabited (<span class="dt">MemberHere</span> <span class="fu">_</span>) <span class="kw">impossible</span>
    uninhabited (<span class="dt">MemberThere</span> <span class="fu">_</span>) <span class="kw">impossible</span></code></pre></div>
<p><code>Uninhabited</code> comes with an <code>absurd</code> funciton of type <code>Uninhabited e =&gt; e -&gt; a</code> absurd can be read as: if we have an instance of an uninhabited type, we can build anything from it.</p>
<p>Thanks to <code>Uninhabited</code>, our instance of <code>Eq</code> can be written:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Eq</span> (<span class="dt">Union</span> []) <span class="kw">where</span>
  (<span class="fu">==</span>) x <span class="fu">_</span> <span class="fu">=</span> absurd x</code></pre></div>
<h1 id="unions-and-synonyms">Unions and synonyms</h1>
<p>If our unions are well defined, a union of a unique type should be isomorphic to this type. A union of two types should be isomorphic to <code>Either</code>. Let’s transform these assumptions into proofs.</p>
<h2 id="morphisms">Morphisms</h2>
<p>The morphisms can be implemented as instances of the <code>Cast</code> typeclass and are straightforward as soon as we know how to deal with uninhabited types:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Cast</span> (<span class="dt">Union</span> [ty]) ty <span class="kw">where</span>
  cast (<span class="dt">MemberHere</span> x) <span class="fu">=</span> x
  cast (<span class="dt">MemberThere</span> x) <span class="fu">=</span> absurd x

<span class="dt">Cast</span> l (<span class="dt">Union</span> [l]) <span class="kw">where</span>
  cast x <span class="fu">=</span> (<span class="dt">MemberHere</span> x)

<span class="dt">Cast</span> (<span class="dt">Union</span> [l, r]) (<span class="dt">Either</span> l r) <span class="kw">where</span>
  cast (<span class="dt">MemberHere</span> x) <span class="fu">=</span> <span class="dt">Left</span> x
  cast (<span class="dt">MemberThere</span> (<span class="dt">MemberHere</span> x)) <span class="fu">=</span> <span class="dt">Right</span> x
  cast (<span class="dt">MemberThere</span> (<span class="dt">MemberThere</span> x)) <span class="fu">=</span> absurd x

<span class="dt">Cast</span> (<span class="dt">Either</span> l r) (<span class="dt">Union</span> [l, r]) <span class="kw">where</span>
  cast (<span class="dt">Left</span> x) <span class="fu">=</span> (<span class="dt">MemberHere</span> x)
  cast (<span class="dt">Right</span> x) <span class="fu">=</span> (<span class="dt">MemberThere</span> (<span class="dt">MemberHere</span> x))</code></pre></div>
<h2 id="put-an-iso-in-our-morphisms">Put an iso in our morphisms</h2>
<p>Idris has a <code>Iso</code> type, that is use to prove that two types are isomorphic. Here is its definition:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Iso</span> <span class="ot">:</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>
  <span class="dt">MkIso</span> <span class="ot">:</span> (to <span class="ot">:</span> a <span class="ot">-&gt;</span> b)
        <span class="ot">-&gt;</span> (from <span class="ot">:</span> b <span class="ot">-&gt;</span> a)
        <span class="ot">-&gt;</span> (toFrom <span class="ot">:</span> (y <span class="ot">:</span> b) <span class="ot">-&gt;</span> to (from y) <span class="fu">=</span> y)
        <span class="ot">-&gt;</span> (fromTo <span class="ot">:</span> (x <span class="ot">:</span> a) <span class="ot">-&gt;</span> from (to x) <span class="fu">=</span> x)
        <span class="ot">-&gt;</span> <span class="dt">Iso</span> a b</code></pre></div>
<p><code>to</code> and <code>from</code> are the two morphisms used to build the isomorphism. <code>toFrom</code> and <code>fromTo</code> are proofs. They are populated if and only if for (<code>to . from</code>) and (<code>from . to</code>) behave like the <code>id</code> function.</p>
<p>Thus, being able to build an instance of <code>Iso a b</code> is a proof that <code>a</code> and <code>b</code> are isomorphic. Let’s buils these instances for <code>Union</code>:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">oneTypeUnion</span> <span class="ot">:</span> <span class="dt">Iso</span> (<span class="dt">Union</span> [ty]) ty
oneTypeUnion <span class="fu">=</span> <span class="dt">MkIso</span> cast cast toFrom fromTo
  <span class="kw">where</span>
    toFrom <span class="fu">_</span> <span class="fu">=</span> <span class="dt">Refl</span>
    fromTo (<span class="dt">MemberHere</span> <span class="fu">_</span>) <span class="fu">=</span> <span class="dt">Refl</span>
    fromTo (<span class="dt">MemberThere</span> x) <span class="fu">=</span> absurd x</code></pre></div>
<p>And:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">eitherUnion</span> <span class="ot">:</span> <span class="dt">Iso</span> (<span class="dt">Union</span> [l, r]) (<span class="dt">Either</span> l r)
eitherUnion <span class="fu">=</span> <span class="dt">MkIso</span> cast cast toFrom fromTo
  <span class="kw">where</span>
    toFrom (<span class="dt">Left</span> <span class="fu">_</span>) <span class="fu">=</span> <span class="dt">Refl</span>
    toFrom (<span class="dt">Right</span> <span class="fu">_</span>) <span class="fu">=</span> <span class="dt">Refl</span>
    fromTo (<span class="dt">MemberHere</span> <span class="fu">_</span>) <span class="fu">=</span> <span class="dt">Refl</span>
    fromTo (<span class="dt">MemberThere</span> (<span class="dt">MemberHere</span> <span class="fu">_</span>)) <span class="fu">=</span> <span class="dt">Refl</span>
    fromTo (<span class="dt">MemberThere</span> (<span class="dt">MemberThere</span> x)) <span class="fu">=</span> absurd x</code></pre></div>
<p><code>Refl</code> is a member of the type <code>x = x</code>. Being able to compile this code build a formal proof of the existence of the isomorphisms.</p>
<h1 id="part-4-is-over">Part 4 is over</h1>
<p>In the <a href="http://nicolas.biri.name/posts/2016-08-14-union-type-in-idris-part-5.html">next part</a>, we’ll discuss union type testing. And, by the way, the code is <a href="https://github.com/berewt/UnionType">on github</a>.</p>
]]></description>
    <pubDate>Tue, 02 Aug 2016 00:00:00 UT</pubDate>
    <guid>http://nicolas.biri.name//posts/2016-08-02-union-type-in-idris-part-4.html</guid>
    <dc:creator>Nicolas Biri</dc:creator>
</item>

    </channel>
</rss>
